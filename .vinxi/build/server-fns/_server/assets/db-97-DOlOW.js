import c from"sqlite3";import{open as T}from"sqlite";import{promises as p}from"fs";import{dirname as R,join as m}from"path";import{a as h}from"./utils-AQpNWTN2.js";import{inflate as w,deflate as y}from"pako";class g{constructor(t){this.db=t}async getAll(){return await this.db.all("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points")||[]}async getByUser(t){return await this.db.all("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE user_id = ?",[t])||[]}async getTotalCount(){return(await this.db.get("SELECT COUNT(*) as count FROM base_points"))?.count||0}async getCountExcludingOrigin(){return(await this.db.get("SELECT COUNT(*) as count FROM base_points WHERE x != 0 OR y != 0"))?.count||0}async getPointsInBounds(t,s,e,r){return await this.db.all(`SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs 
       FROM base_points 
       WHERE x BETWEEN ? AND ? AND y BETWEEN ? AND ?`,[t,e,s,r])||[]}async add(t,s,e){const r=Date.now();try{await this.db.run("BEGIN TRANSACTION");try{const a=await this.db.get("SELECT COUNT(*) as count FROM users WHERE id = ?",[t]);if(!a||a.count===0)throw new Error(`User ${t} not found`);const i=await this.db.get("SELECT id, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE user_id = ? AND x = ? AND y = ?",[t,s,e]);if(i)return await this.db.run("COMMIT"),i;const d=await this.db.run("INSERT INTO base_points (user_id, x, y, game_created_at_ms) VALUES (?, ?, ?, ?)",[t,s,e,r]);await this.db.run("COMMIT");const u=await this.db.get("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE id = ?",[d.lastID]);if(!u)throw new Error("Failed to retrieve created base point");return u}catch(a){throw console.error("[BasePointRepository] Error in transaction:",a),await this.db.run("ROLLBACK"),a}}catch(a){throw console.error("[BasePointRepository] Error in add method:",{error:a instanceof Error?a.message:"Unknown error",stack:a instanceof Error?a.stack:void 0,userId:t,x:s,y:e,now:r,dbState:{userExists:await this.db.get("SELECT id, username FROM users WHERE id = ?",[t]),basePoints:await this.db.all("SELECT * FROM base_points WHERE user_id = ?",[t])}}),new Error(`Failed to add base point: ${a instanceof Error?a.message:"Unknown error"}`)}}async deleteAllBasePointsForUser(t){await this.db.run("DELETE FROM base_points WHERE user_id = ?",[t])}async deletePoints(t){if(t.length===0)return;const s=await this.db.get("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE id = ?",[t[0].id]);if(s){await this.db.run("BEGIN TRANSACTION");try{await this.db.run("DELETE FROM base_points WHERE id IN ("+t.map(()=>"?").join(",")+")",t.map(a=>a.id));const{basePointEventService:e}=await import("./base-point-events-C2UNy6C4.js"),r={...s,count:t.length};e.emitDeleted(r),await this.db.run("COMMIT")}catch(e){throw await this.db.run("ROLLBACK"),console.error(`[BasePointRepository] Failed to delete ${t.length} points:`,e),e}}}async create(t){const{userId:s,x:e,y:r,gameCreatedAtMs:a}=t;return{id:(await this.db.run("INSERT INTO base_points (user_id, x, y, game_created_at_ms) VALUES (?, ?, ?, ?)",[s,e,r,a])).lastID,userId:s,x:e,y:r,createdAtMs:a}}async getOldest(){return await this.db.get("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE x != 0 OR y != 0 ORDER BY game_created_at_ms ASC LIMIT 1")||null}async delete(t){return((await this.db.run("DELETE FROM base_points WHERE id = ?",[t])).changes||0)>0}async deleteBasePoint(t){const s=await this.db.get("SELECT id, user_id as userId, x, y, game_created_at_ms as createdAtMs FROM base_points WHERE id = ?",[t]);if(!s)return null;await this.db.run("BEGIN TRANSACTION");try{await this.db.run("DELETE FROM base_points WHERE id = ?",[t]);const{basePointEventService:e}=await import("./base-point-events-C2UNy6C4.js");return e.emitDeleted(s),await this.db.run("COMMIT"),s}catch(e){throw await this.db.run("ROLLBACK"),console.error(`[BasePointRepository] Failed to delete point ${t}:`,e),e}}}const M=6;class O{constructor(t){this.db=t}static TILE_SIZE=64;async getTile(t,s){const e=await this.db.get("SELECT tile_x, tile_y, data, version, last_updated_ms FROM map_tiles WHERE tile_x = ? AND tile_y = ?",[t,s]);if(!e)return null;const r=e.data;let a;if(r.length>0){const i=r[0],d=r.subarray(1);i===1?a=w(d):a=new Uint8Array(d)}else a=new Uint8Array(0);return{tileX:e.tile_x,tileY:e.tile_y,data:a,compressedData:e.data,version:e.version,lastUpdatedMs:e.last_updated_ms}}async saveTile(t){const s=Date.now(),e=(t.version||0)+1;let r=t.compressedData;if(!r&&t.data){const a=Buffer.alloc(1);a[0]=1;const i=y(t.data,{level:M});r=Buffer.concat([a,Buffer.from(i)])}await this.db.run(`INSERT INTO map_tiles (tile_x, tile_y, data, version, last_updated_ms)
       VALUES (?, ?, ?, ?, ?)
       ON CONFLICT(tile_x, tile_y) DO UPDATE SET
         data = excluded.data,
         version = excluded.version,
         last_updated_ms = excluded.last_updated_ms`,[t.tileX,t.tileY,r,e,s])}async getTilesInBounds(t,s,e,r){return(await this.db.all("SELECT tile_x, tile_y, data, version, last_updated_ms FROM map_tiles WHERE tile_x BETWEEN ? AND ? AND tile_y BETWEEN ? AND ?",[t,e,s,r])).map(i=>({tileX:i.tile_x,tileY:i.tile_y,data:i.data,compressedData:i.data,version:i.version,lastUpdatedMs:i.last_updated_ms}))}static worldToTileCoords(t,s){return{tileX:Math.floor(t/this.TILE_SIZE),tileY:Math.floor(s/this.TILE_SIZE)}}static getTileBounds(t,s){return{minX:t*this.TILE_SIZE,minY:s*this.TILE_SIZE,maxX:(t+1)*this.TILE_SIZE-1,maxY:(s+1)*this.TILE_SIZE-1}}async deleteAllTiles(){await this.db.run("DELETE FROM map_tiles")}}const A=process.env.DATA_DIR||m(process.cwd(),"data"),_=m(A,"app.db");let o,l=null,E=null;async function b(){if(h(),!o){console.log("Initializing database connection...");try{await p.mkdir(R(_),{recursive:!0}),o=await T({filename:_,driver:c.Database,mode:c.OPEN_READWRITE|c.OPEN_CREATE}),await o.exec("PRAGMA journal_mode = WAL;"),await o.exec("PRAGMA foreign_keys = ON;"),console.log("Database connection established")}catch(n){throw console.error("Failed to initialize database:",n),n}}return o}async function D(){if(!l){const n=await b();l=new g(n)}return l}async function x(){if(!E){const n=await b();E=new O(n)}return E}export{g as B,O as M,D as a,x as b,b as g};
