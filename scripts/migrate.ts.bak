import { join, dirname } from 'path';
import { readdir, mkdir, readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import sqlite3 from 'sqlite3';
import { 
  Database,
  getDbConnection, 
  getAllTables, 
  getAppliedMigrations,
  tableExists,
  getTableRowCount,
  ensureDataDirectory,
  execute,
  SqlParams,
  DbMigration
} from './utils/db-utils';

// Extend the Database type to include required methods
type DatabaseWithRun = Database & {
  run: (sql: string, ...params: any[]) => Promise<{ lastID?: number | bigint; changes?: number }>;
  close: () => Promise<void>;
  all: <T = any>(sql: string, ...params: any[]) => Promise<T[]>;
  get: <T = any>(sql: string, ...params: any[]) => Promise<T | undefined>;
  exec: (sql: string) => Promise<void>;
  serialize?: () => void;
  parallelize?: () => void;
};

// Type for migration functions
type MigrationFunction = (db: DatabaseWithRun) => Promise<void>;


const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const MIGRATIONS_DIR = join(__dirname, 'migrations');
const DB_PATH = join(process.cwd(), 'data', 'app.db');

// Types
interface MigrationFile {
  id: string;
  name: string;
  up: MigrationFunction;
  down?: MigrationFunction;
}

interface MigrationResult {
  success: boolean;
  applied: number;
  initialized?: boolean;
  error?: string;
  tables?: any[];
  totalMigrations?: number;
  pendingMigrations?: string[];
}

interface InitResult {
  success: boolean;
  error?: string;
  tablesCreated: string[];
}

async function ensureMigrationsTable(db: DatabaseWithRun): Promise<void> {
  await db.exec(`
    CREATE TABLE IF NOT EXISTS migrations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL UNIQUE,
      applied_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `);
}

async function getMigrationFiles(): Promise<string[]> {
  try {
    const files = await readdir(MIGRATIONS_DIR);
    return files
      .filter(file => file.endsWith('.js') || file.endsWith('.ts'))
      .sort();
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('Migrations directory not found, creating...');
      await mkdir(MIGRATIONS_DIR, { recursive: true });
      return [];
    }
    throw error;
  }
}

async function loadMigration(file: string): Promise<MigrationFile> {
  const filePath = join(MIGRATIONS_DIR, file);
  const content = await readFile(filePath, 'utf8');
  
  // Extract the migration ID and name from the filename
  const match = file.match(/^(\d+)_([^.]+)\.(js|ts)$/);
  if (!match) {
    throw new Error(`Invalid migration filename: ${file}`);
  }
  
  const [_, id, name] = match;
  
  // Create a module-like object with the migration code
  // Create a module-like object with the migration code
  const module = { 
    exports: {} as { 
      up: MigrationFunction; 
      down?: MigrationFunction 
    } 
  };
  
  // Create a simple require function for migrations
  const require = (path: string) => {
    if (path === 'sqlite3') {
      // Return a minimal sqlite3-compatible object
      return {
        Database: sqlite3.Database,
        verbose: () => ({
          Database: sqlite3.verbose().Database
        })
      };
    }
    throw new Error(`Cannot require ${path} in migration`);
  };
  
  // Execute the migration code in a safe context
  try {
    // Use the Function constructor to create the migration function
    // This is safe because we control the input (migration files)
    const fn = new Function('module', 'exports', 'require', content);
    
    // Call the function with our module context
    fn(module, module.exports, require);
    
    // Validate the exported 'up' function
    if (typeof module.exports.up !== 'function') {
      throw new Error('Migration must export an "up" function');
    }
    
    // Validate the exported 'down' function if it exists
    if (module.exports.down && typeof module.exports.down !== 'function') {
      throw new Error('If provided, "down" must be a function');
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    throw new Error(`Error loading migration ${file}: ${errorMessage}`);
  }
  
  // Type assertion to ensure the migration has the correct shape
  const migration = module.exports as { up: MigrationFunction; down?: MigrationFunction };
  
  return {
    id,
    name,
    up: module.exports.up,
    down: module.exports.down
  };
}

async function runMigrations(): Promise<MigrationResult> {
  console.log('\n=== Database Migration ===');
  const startTime = Date.now();
  
  try {
    // 1. Ensure data directory exists
    await ensureDataDirectory();
    
    // 2. Initialize database connection
    console.log('\n1. Connecting to database...');
    const db = await getDbConnection();
    const dbWithRun = db as unknown as DatabaseWithRun;
    
    try {
      // 3. Show current state before migration
      console.log('\n2. Current database state:');
      
      // 4. Get all migration files
      console.log('\n3. Checking for migration files...');
      await mkdir(MIGRATIONS_DIR, { recursive: true });
      const migrationFiles = await getMigrationFiles();
      console.log(`   Found ${migrationFiles.length} migration files`);
      
      // 5. Ensure migrations table exists and get applied migrations
      console.log('\n4. Checking for applied migrations...');
      await ensureMigrationsTable(dbWithRun);
      const appliedMigrations = await getAppliedMigrations(dbWithRun);
      console.log(`   Found ${appliedMigrations.length} applied migrations`);
      
      // 6. Find pending migrations
      const pendingMigrations = migrationFiles.filter(
        file => !appliedMigrations.some(m => m.name === file.replace(/\.[^/.]+$/, ''))
      ).sort((a, b) => {
        // Sort migrations by their numeric prefix
        const aNum = parseInt(a.split('_')[0], 10);
        const bNum = parseInt(b.split('_')[0], 10);
        return aNum - bNum;
      });
      
      if (pendingMigrations.length === 0) {
        console.log('‚úÖ Database is up to date');
        return { success: true, applied: 0, totalMigrations: migrationFiles.length };
      }
      
      console.log(`Found ${pendingMigrations.length} pending migrations`);
      
      // Apply pending migrations
      let appliedCount = 0;
      for (const file of pendingMigrations) {
        try {
          console.log(`\nüîπ Applying migration: ${file}`);
          const migration = await loadMigration(file);
          
          // Start a transaction
          await dbWithRun.run('BEGIN TRANSACTION');
          
          try {
            // Run the migration
            await migration.up(dbWithRun);
            
            // Record the migration
            await dbWithRun.run(
              "INSERT INTO migrations (name, applied_at) VALUES (?, strftime('%s', 'now'))",
              migration.name
            );
            
            // Commit the transaction
            await dbWithRun.run('COMMIT');
            
            console.log(`‚úÖ Applied migration: ${file}`);
            appliedCount++;
            
          } catch (error) {
            // Rollback on error
            await dbWithRun.run('ROLLBACK');
            throw error;
          }
          
        } catch (error: unknown) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          console.error(`‚ùå Failed to apply migration ${file}:`, errorMessage);
          return {
            success: false,
            applied: appliedCount,
            error: `Migration failed: ${file} - ${errorMessage}`,
            pendingMigrations: pendingMigrations.slice(appliedCount)
          };
        }
      }
      
      console.log(`\n‚úÖ Successfully applied ${appliedCount} migrations`);
      return {
        success: true,
        applied: appliedCount,
        totalMigrations: migrationFiles.length
      };
      
    } finally {
      await db.close();
    }
    
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error during migration';
    console.error('\n‚ùå Migration failed:', errorMessage);
    return {
      success: false,
      applied: 0,
      error: errorMessage
    };
  } finally {
    console.log(`‚è±Ô∏è  Migration completed in ${((Date.now() - startTime) / 1000).toFixed(2)}s`);
  }
}

async function initializeDatabase(): Promise<InitResult> {
  const startTime = Date.now();
  console.log('\n=== Database Initialization ===');
  
  try {
    await ensureDataDirectory();
    const db = await getDbConnection();
    const tablesCreated: string[] = [];

    try {
      // Enable foreign keys
      await db.exec('PRAGMA foreign_keys = ON;');
      
      // Create migrations table if it doesn't exist
      await db.exec(`
        CREATE TABLE IF NOT EXISTS migrations (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL UNIQUE,
          applied_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
        );
      `);
      tablesCreated.push('migrations');

      // Create users table if it doesn't exist
      await db.exec(`
        CREATE TABLE IF NOT EXISTS users (
          id TEXT PRIMARY KEY,
          username TEXT NOT NULL UNIQUE,
          created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
          updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
        );
      `);
      tablesCreated.push('users');

      // Create sessions table if it doesn't exist
      await db.exec(`
        CREATE TABLE IF NOT EXISTS sessions (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          expires_at INTEGER NOT NULL,
          created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
          FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );
      `);
      tablesCreated.push('sessions');

      // Create base_points table if it doesn't exist
      await db.exec(`
        CREATE TABLE IF NOT EXISTS base_points (
          id TEXT PRIMARY KEY,
          user_id TEXT NOT NULL,
          name TEXT NOT NULL,
          description TEXT,
          created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
          updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
          FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );
      `);
      tablesCreated.push('base_points');

      console.log(`‚úÖ Database initialized with ${tablesCreated.length} tables`);
      return { success: true, tablesCreated };
    } finally {
      await db.close();
    }
  } catch (error) {
    console.error('‚ùå Database initialization failed:', error);
    return { success: false, error: error.message, tablesCreated: [] };
  } finally {
    console.log(`‚è±Ô∏è  Initialization completed in ${((Date.now() - startTime) / 1000).toFixed(2)}s`);
  }
}

async function runMigrations(): Promise<MigrationResult> {
  console.log('\n=== Database Migration ===');
  const startTime = Date.now();
  
  try {
    // 1. Ensure data directory exists
    await ensureDataDirectory();
    
    // 2. Initialize database connection
    console.log('\n1. Connecting to database...');
    const db = await getDbConnection();
    
    try {
      // 2. Show current state before migration
      console.log('\n2. Current database state:');
      
      // Get existing migrations
      await ensureMigrationsTable(db);
      const currentMigrations = await getAppliedMigrations(db);
      console.log(`   ‚Ä¢ Found ${currentMigrations.length} existing migrations`);
      
      if (currentMigrations.length > 0) {
        const latest = currentMigrations[currentMigrations.length - 1];
        console.log(`   ‚Ä¢ Latest migration: ${latest.name} (${new Date(latest.applied_at * 1000).toISOString()})`);
      }
      
      // Get current tables
      const tables = await getAllTables(db);
      console.log(`   ‚Ä¢ Found ${tables.length} tables`);
      
      // 3. Find and run new migrations
      const migrationFiles = (await readdir(MIGRATIONS_DIR))
        .filter(f => f.endsWith('.ts') && f !== 'index.ts' && f !== 'template.ts')
        .sort();
      
      if (migrationFiles.length === 0) {
        console.log('\n‚ÑπÔ∏è  No migration files found');
        return { success: true, applied: 0, tables, totalMigrations: currentMigrations.length };
      }
      
      const appliedMigrations = new Set(
        currentMigrations.map((m: any) => m.name)
      );
      
      const pendingMigrations = migrationFiles.filter(f => !appliedMigrations.has(f));
      
      if (pendingMigrations.length === 0) {
        console.log(`\n‚úÖ All ${migrationFiles.length} migrations already applied`);
        return { success: true, applied: 0, tables, totalMigrations: currentMigrations.length };
      }
      
      console.log(`\n3. Found ${pendingMigrations.length} new migrations to apply`);
      
      // 4. Run migrations in transaction
      await db.run('BEGIN TRANSACTION');
      
      try {
        for (const file of pendingMigrations) {
          const startTime = Date.now();
          console.log(`\n   üîÑ Applying: ${file}`);
          
          // Import and run migration
          const migration = await import(join(MIGRATIONS_DIR, file));
          await migration.up(db);
          
          // Record migration
          await db.run('INSERT INTO migrations (name) VALUES (?)', [file]);
          
          const duration = ((Date.now() - startTime) / 1000).toFixed(2);
          console.log(`   ‚úÖ Applied in ${duration}s`);
        }
        
        await db.run('COMMIT');
        
        // 5. Show updated state
        console.log('\n4. Updated database state:');
        
        const updatedTables = await getAllTables(db);
        console.log(`   ‚Ä¢ Found ${updatedTables.length} tables`);
        
        if (updatedTables.length > 0) {
          console.log('\n   Tables:');
          console.table(updatedTables.map(t => ({
            Name: t.name,
            Type: t.type,
            'Row Count': t.rowCount >= 0 ? t.rowCount : 'N/A'
          })));
        }
        
        const updatedMigrations = await getAppliedMigrations(db);
        console.log(`\n‚úÖ Successfully applied ${pendingMigrations.length} migrations`);
        console.log(`   ‚Ä¢ Total migrations: ${updatedMigrations.length}`);
        
        const duration = ((Date.now() - startTime) / 1000).toFixed(2);
        console.log(`\n‚ú® Migration completed in ${duration}s`);
        
        return { 
          success: true, 
          applied: pendingMigrations.length, 
          tables: updatedTables,
          totalMigrations: updatedMigrations.length
        };
        
      } catch (error) {
        await db.run('ROLLBACK');
        console.error('\n‚ùå Migration failed, rolling back changes...');
        throw error;
      }
      
    } finally {
      await db.close();
    }
    
  } catch (error) {
    console.error('\n‚ùå Migration failed:', error.message);
    return { 
      success: false, 
      applied: 0, 
      error: error.message,
      tables: []
    };
  }
}

// Main function to handle CLI commands
async function main() {
  const command = process.argv[2];
  
  try {
    switch (command) {
      case 'init':
        const { success: initSuccess, error: initError, tablesCreated } = await initializeDatabase();
        if (initSuccess) {
          console.log('\n‚úÖ Database initialized successfully');
          if (tablesCreated.length > 0) {
            console.log('\nCreated tables:', tablesCreated.join(', '));
          }
        } else {
          throw new Error(initError || 'Unknown error during initialization');
        }
        break;
        
      case 'migrate':
      case undefined:
        const migrationResult = await runMigrations();
        if (!migrationResult.success) {
          throw new Error(migrationResult.error || 'Migration failed');
        }
        break;
        
      case 'help':
      default:
        showHelp();
        break;
    }
  } catch (error) {
    console.error('\n‚ùå Error:', error.message);
    process.exit(1);
  }
}

function showHelp() {
  console.log(`
Database Migration Tool

Usage:
  npx tsx scripts/migrate.ts [command]

Commands:
  init      Initialize database with required tables
  migrate   Run database migrations (default)
  help      Show this help message

Examples:
  npx tsx scripts/migrate.ts init
  npx tsx scripts/migrate.ts migrate
`);
}

// Execute the appropriate command
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('\n‚ùå Fatal error:', error);
    process.exit(1);
  });
}

export {
  runMigrations,
  initializeDatabase,
  ensureMigrationsTable,
  getMigrationFiles,
  loadMigration
};
